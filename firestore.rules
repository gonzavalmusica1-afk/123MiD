/**
 * @fileoverview Firestore Security Rules for Alerta Vital Project
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and allows for public or private bracelets.
 * Bracelets can be claimed by authenticated users if they are unclaimed and the PIN matches.
 * Configuration data is publicly readable but write-protected.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data. Each user can only access their own profile.
 * - /bracelets/{braceletId}: Stores bracelet data. Access is controlled by the 'privacy' field and ownership ('userId').
 * - /config/{document=**}: Stores configuration data, accessible to everyone for reading.
 *
 * Key Security Decisions:
 * - Users can only access their own data under /users/{userId}.
 * - Listing of users is disallowed.
 * - Public read access to bracelets is granted only if the 'privacy' field is set to 'public' or the user is the owner.
 * - Bracelet claiming is allowed for unclaimed bracelets with matching PINs.
 * - Configuration data is publicly readable but only writeable by authenticated users.
 *
 * Denormalization for Authorization:
 * - Bracelet documents include a `userId` field to determine ownership, avoiding the need for separate lookups.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user-specific data. Only the authenticated user can access their own profile.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get, update, delete: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow list: if false;
    }

    /**
     * @description Controls access to bracelets. Allows public reads for public bracelets, owner-only writes, and claiming unclaimed bracelets with a matching PIN.
     * @path /bracelets/{braceletId}
     */
    match /bracelets/{braceletId} {
      allow get: if isPublicRead(get(thisResource()).data.privacy) || (isSignedIn() && isOwner(get(thisResource()).data.userId));
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (isOwner(get(thisResource()).data.userId) || canClaim(get(thisResource()).data.userId, get(thisResource()).data.pin, request.resource.data.pin));
      allow delete: if isSignedIn() && isOwner(get(thisResource()).data.userId);
    }

     /**
      * @description Allows public read access to configuration data.
      * @path /config/{document=**}
      */
    match /config/{document=**} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn();
    }

  }

  /**
   * @description Checks if the user is signed in.
   * @return {boolean} True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the authenticated user is the owner of the resource.
   * @param {string} userId The user ID to compare against the authenticated user's ID.
   * @return {boolean} True if the user is the owner, false otherwise.
   */
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  /**
   * @description Checks if the bracelet can be claimed (no owner and PIN matches).
   * @param {string} existingUserId The existing user ID of the bracelet (should be null).
   * @param {string} existingPin The existing PIN of the bracelet.
   * @param {string} newPin The new PIN being provided in the request.
   * @return {boolean} True if the bracelet is unclaimed and the PIN matches.
   */
  function canClaim(existingUserId, existingPin, newPin) {
    return (existingUserId == null && newPin == existingPin);
  }

  /**
   * @description Checks if the document can be read publicly.
   * @param {string} privacy The privacy setting of the document.
   * @return {boolean} True if privacy is set to "public".
   */
  function isPublicRead(privacy) {
    return privacy == 'public';
  }

  /**
   * @description Returns the resource being requested.
   * @return {resource} The resource object.
   */
  function thisResource() {
      return request.path
  }
}
