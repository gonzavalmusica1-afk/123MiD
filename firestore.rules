/**
 * @fileoverview Firestore Security Rules for Alerta Vital Project
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles and allows for public or private bracelets.
 * Bracelets can be claimed by authenticated users if they are unclaimed and the PIN matches.
 * Configuration data is publicly readable but write-protected.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data. Each user can only access their own profile.
 * - /bracelets/{braceletId}: Stores bracelet data. Access is controlled by the 'privacy' field and ownership ('userId').
 * - /config/{document=**}: Stores configuration data, accessible to everyone for reading.
 *
 * Key Security Decisions:
 * - Users can only access their own data under /users/{userId}.
 * - Listing of users is disallowed.
 * - Public read access to bracelets is granted only if the 'privacy' field is set to 'public'.
 * - Bracelet claiming is allowed for unclaimed bracelets with matching PINs.
 * - Configuration data is publicly readable but only writeable by authenticated users.
 *
 * Denormalization for Authorization:
 * - Bracelet documents include a `userId` field to determine ownership, avoiding the need for separate lookups.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user-specific data. Only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (get, update, delete) User 'user_abc' can access /users/user_abc.
     * @deny (get, update, delete) User 'user_xyz' cannot access /users/user_abc.
     * @allow (create) User 'user_abc' can create /users/user_abc.
     * @deny (create) User 'user_xyz' cannot create /users/user_abc.
     * @deny (list) Listing users is not allowed.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to bracelets. Allows public reads for public bracelets, owner-only writes, and claiming unclaimed bracelets with a matching PIN.
     * @path /bracelets/{braceletId}
     * @allow (get) Anyone can read a bracelet if privacy is set to "public".
     * @allow (get) User 'user_abc' can read /bracelets/bracelet_123 if they own it (bracelet_123.userId == 'user_abc').
     * @deny (get) User 'user_xyz' cannot read a private bracelet owned by 'user_abc'.
     * @allow (list) Authenticated users can list bracelets (filtering must be done on the client).
     * @allow (create) Authenticated users can create new bracelets.
     * @allow (update, delete) User 'user_abc' can update or delete /bracelets/bracelet_123 if they own it (bracelet_123.userId == 'user_abc').
     * @allow (update) Anyone can claim an unclaimed bracelet with the correct PIN by setting the userId.
     * @deny (update, delete) User 'user_xyz' cannot update or delete a bracelet owned by 'user_abc'.
     * @principle Manages bracelet access based on privacy settings, ownership, and claiming rules.
     */
    match /bracelets/{braceletId} {
      allow get: if isPublicRead(get(thisResource()).data.privacy, get(thisResource()).data.userId) || (isSignedIn() && isOwner(get(thisResource()).data.userId));
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (isOwner(get(thisResource()).data.userId) || canClaim(get(thisResource()).data.userId, get(thisResource()).data.pin, request.resource.data.pin));
      allow delete: if isSignedIn() && isOwner(get(thisResource()).data.userId);
    }

     /**
      * @description Allows public read access to configuration data.
      * @path /config/{document=**}
      * @allow (get, list) Anyone can read configuration data.
      * @allow (create, update, delete) Authenticated users can create, update, or delete configuration data.
      * @principle Grants public read access to configuration data while restricting writes to authenticated users.
      */
    match /config/{document=**} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn();
    }

  }

  /**
   * @description Checks if the user is signed in.
   * @param {void}
   * @return {boolean} True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the authenticated user is the owner of the resource.
   * @param {string} userId The user ID to compare against the authenticated user's ID.
   * @return {boolean} True if the user is the owner, false otherwise.
   */
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  /**
   * @description Combines ownership check with existence check for updates and deletes.
   * @param {string} userId The user ID to compare against the authenticated user's ID.
   * @return {boolean} True if the user is the owner and the document exists.
   */
  // function isExistingOwner(userId) {
  //   return isOwner(userId) && resource != null;
  // }

  /**
   * @description Checks if the bracelet can be claimed (no owner and PIN matches).
   * @param {string} existingUserId The existing user ID of the bracelet (should be null).
   * @param {string} existingPin The existing PIN of the bracelet.
   * @param {string} newPin The new PIN being provided in the request.
   * @return {boolean} True if the bracelet is unclaimed and the PIN matches.
   */
  function canClaim(existingUserId, existingPin, newPin) {
    return (existingUserId == null && newPin == existingPin);
  }

  /**
   * @description Checks if the document can be read publicly.
   * @param {string} privacy The privacy setting of the document.
   * @param {string} userId The userId on the document.
   * @return {boolean} True if privacy is set to "public" or the doc doesn't have a userId.
   */
  function isPublicRead(privacy, userId) {
    return privacy == 'public';
  }

    function thisResource() {
      return request.path
    }
}